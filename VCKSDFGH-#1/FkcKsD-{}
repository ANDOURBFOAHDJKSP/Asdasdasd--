local openshit = Instance.new("ScreenGui")
local mainopen = Instance.new("TextButton")
local mainopens = Instance.new("UICorner")
local loki = Instance.new("ImageLabel")
local posto = Instance.new("UIStroke")

openshit.Name = "openshit"
openshit.Parent = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
openshit.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
openshit.ResetOnSpawn = false

mainopen.Name = "mainopen"
mainopen.Parent = openshit
mainopen.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
mainopen.Position = UDim2.new(0.101969875, 0, 0.110441767, 0)
mainopen.Size = UDim2.new(0, 64, 0, 42)
mainopen.Text = ""
mainopen.Visible = true

mainopens.Parent = mainopen
 
loki.Name = "loki"
loki.Parent = mainopen
loki.BackgroundColor3 = Color3.fromRGB(224,224,224)
loki.BackgroundTransparency = 1.000
loki.Position = UDim2.new(-0.0529999994, 0, -0.244000003, 0)
loki.Size = UDim2.new(0, 69, 0, 62)
loki.Image = "rbxassetid://17339439921"
 
posto.Name = "posto"
posto.Parent = mainopen
posto.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
posto.Color = Color3.fromRGB(224,224,224)
posto.LineJoinMode = Enum.LineJoinMode.Round
posto.Thickness = 1
posto.Transparency = 0
posto.Enabled = true
posto.Archivable = true
 
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
 
local function MakeDraggable(topbarobject, object)
    local Dragging = nil
    local DragInput = nil
    local DragStart = nil
    local StartPosition = nil
    
    local function Update(input)
        local Delta = input.Position - DragStart
        local pos = UDim2.new(StartPosition.X.Scale, StartPosition.X.Offset + Delta.X, StartPosition.Y.Scale, StartPosition.Y.Offset + Delta.Y)
        local Tween = TweenService:Create(object, TweenInfo.new(0.15), {
            Position = pos
        })
        Tween:Play()
    end
    
    topbarobject.InputBegan:Connect(
        function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                Dragging = true
                DragStart = input.Position
                StartPosition = object.Position
                
                input.Changed:Connect(
                    function()
                        if input.UserInputState == Enum.UserInputState.End then
                            Dragging = false
                        end
                    end
                )
            end
        end
    )
    
    topbarobject.InputChanged:Connect(
        function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                DragInput = input
            end
        end
    )
    
    UserInputService.InputChanged:Connect(
        function(input)
            if input == DragInput and Dragging then
                Update(input)
            end
        end
    )
end

MakeDraggable(mainopen, mainopen) -- Making the button draggable

mainopen.MouseButton1Click:Connect(function()
    game:GetService("VirtualInputManager"):SendKeyEvent(true, "LeftControl", false, game)
    game:GetService("VirtualInputManager"):SendKeyEvent(false, "LeftControl", false, game)
end)

local player = game:GetService("Players").LocalPlayer
local RunService = game:GetService("RunService")

local fpsCounter = Instance.new("ScreenGui")
fpsCounter.Parent = game.CoreGui
fpsCounter.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
fpsCounter.ResetOnSpawn = false

local label = Instance.new("TextLabel")
label.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
label.BackgroundTransparency = 1.000
label.TextColor3 = Color3.fromRGB(255, 255, 255)
label.Font = Enum.Font.GothamBlack
label.Size = UDim2.new(0, 150, 0, 70)
label.Position = UDim2.new(0, 200, 0, 10)
label.Text = "FPS: 0\nTime Played: 0h 0m 0s"
label.TextSize = 10
label.Parent = fpsCounter

local startTime = tick()
local lastUpdateTime = tick()
local frameCount = 0

RunService.RenderStepped:Connect(function()
    local currentTime = tick()
    local deltaTime = currentTime - lastUpdateTime
    frameCount = frameCount + 1

    if deltaTime >= 1 then
        local fps = math.round(frameCount / deltaTime)
        local elapsedTime = currentTime - startTime

        local hours = math.floor(elapsedTime / 3600)
        local minutes = math.floor((elapsedTime % 3600) / 60)
        local seconds = math.floor(elapsedTime % 60)

        label.Text = "FPS: " .. fps .. "\nTime Played: " .. hours .. "h " .. minutes .. "m " .. seconds .. "s"

        lastUpdateTime = currentTime
        frameCount = 0
    end
end)

print("HWID FOUND!")

print("-- Fast Main Loader V3")
print("-- Unknown TQ Hub 1/5: Checking Game...")

print("-- Unknown TQ Hub 2/5: Getting Service...")

-- Test literally
local request = http_request or request or HttpPost

-- waiting for game load
while not game:IsLoaded() do
    RunService.RenderStepped:Wait()
end

-- Valuable 1
repeat wait() until game:IsLoaded()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")
local HttpService = game:GetService("HttpService")
local Player = Players.LocalPlayer
local InventoryController = require(game:GetService("Players").LocalPlayer.PlayerScripts:WaitForChild("Shared"):WaitForChild("Client"):WaitForChild("InventoryController"))

print("-- Unknown TQ Hub 3/5: Bypassing Random Name...")

print("-- Unknown TQ Hub 3.5/5: Bypassing... *DumbExploiterController* ")

-- Valuable Servers
local isWaveDefense
local isEventDungeon
local isMainDungeon
local isLobby = game.PlaceId == 2960777560

function bypassAntiCheat()
    local exploiterController = game:GetService("Players").LocalPlayer.PlayerScripts.Shared.Client:WaitForChild(
        'DumbExploiterController')

    -- bypass anti-cheat
    local cheat = require(exploiterController)
    cheat._Update = function()
        return
    end

    cheat._SetupDummyRemotes = function()
        return
    end

    while not game:GetService("Players") do
        wait()
    end

    while not game:GetService("ReplicatedStorage") do
        wait()
    end

    task.wait(2)

    game:GetService("Players").Name = 'Players'
    game:GetService("ReplicatedStorage").Name = 'ReplicatedStorage'
    workspace.Name = 'Workspace'

    if isLobby then
        return
    end

    workspace:GetChildren()[5].Name = 'Dungeon'

    -- Wave defense
    if workspace.Dungeon:FindFirstChild("EnemySpawns") then
        workspace.Dungeon:GetChildren()[5].Name = 'Enemies'
        isWaveDefense = workspace.Dungeon:FindFirstChild("EnemySpawns")
        return
    end

    -- Nomal dungeon
    workspace.Dungeon:GetChildren()[1].Name = 'Enemies'
    workspace.Dungeon:GetChildren()[2].Name = 'Rooms'

    -- Grand Grotto
    if workspace.Dungeon.Rooms:FindFirstChild("Start"):FindFirstChild("Traps") then
        isEventDungeon = true
end

-- Dungeon
    if workspace.Dungeon.Rooms:FindFirstChild("Start") then
        isMainDungeon = true
   end
end

bypassAntiCheat()

function getPlayer()
    while not game:GetService('Players').LocalPlayer do
        RunService.RenderStepped:Wait()
    end
    while not game:GetService('Players').LocalPlayer.Character do
        RunService.RenderStepped:Wait()
    end
    while not game:GetService('Players').LocalPlayer.Character:FindFirstChild("HumanoidRootPart") do
        RunService.RenderStepped:Wait()
    end
    while not game:GetService('Players').LocalPlayer.Character:FindFirstChild("Humanoid") do
        RunService.RenderStepped:Wait()
    end

    local player = game:GetService('Players').LocalPlayer
    local cha = game:GetService('Players').LocalPlayer.Character
    local plr = game:GetService('Players').LocalPlayer.Character.HumanoidRootPart
    local hum = game:GetService('Players').LocalPlayer.Character.Humanoid
    return player, cha, plr, hum
end

-- Function to get dungeon components
function getDungeon()

    while not game:GetService("Workspace"):FindFirstChild("Dungeon") do
        RunService.RenderStepped:Wait()
    end
    while not game:GetService("Workspace"):FindFirstChild("Dungeon"):FindFirstChild("Rooms") do
        RunService.RenderStepped:Wait()
    end
    while not game:GetService("Workspace"):FindFirstChild("Dungeon"):FindFirstChild("Enemies") do
        RunService.RenderStepped:Wait()
    end
    while not game:GetService("Workspace"):FindFirstChild("Dungeon"):FindFirstChild("Shrines") do
        RunService.RenderStepped:Wait()
    end

    local dungeon = game:GetService("Workspace").Dungeon
    local rooms = dungeon.Rooms
    local enemies = dungeon.Enemies
    local shrines = dungeon.Shrines
    return dungeon, rooms, enemies, shrines
end

function getWaveDefense()
    while not game:GetService("Workspace"):FindFirstChild("Dungeon") do
        RunService.RenderStepped:Wait()
    end
    while not game:GetService("Workspace"):FindFirstChild("Dungeon"):FindFirstChild("Rooms") do
        RunService.RenderStepped:Wait()
    end
    while not game:GetService("Workspace"):FindFirstChild("Dungeon"):FindFirstChild("Enemies") do
        RunService.RenderStepped:Wait()
    end
    local dungeon = game:GetService("Workspace").Dungeon
    local enemies = dungeon.Enemies
    local rooms = dungeon.Rooms
    return dungeon, rooms, enemies
end

function getNearestTarget()
    local target
    local closet = math.huge
    local player, cha, plr, hum = getPlayer()
    local dungeon, rooms, enemies, shrines = getDungeon()
    for _, v in pairs(enemies:GetChildren()) do
        if v:FindFirstChild("EvilHumanoid") and v:FindFirstChild("HumanoidRootPart") and v.EvilHumanoid.Health > 0 then
            local distance = (v.HumanoidRootPart.Position - plr.Position).Magnitude
            if distance < closet then
                closet = distance
                target = v
            end
        end
    end
    return target
end

function getNearestAttack()
    local nearestAttack = nil
    local closestDistance = math.huge
    local player, cha, plr, hum = getPlayer()
    for _, v in pairs(workspace:GetChildren()) do
        if v:IsA("BasePart") then
            local distance = (v.Position - plr.Position).Magnitude
            if distance < closestDistance then
                closestDistance = distance
                nearestAttack = v
            end
        end
    end

    return nearestAttack, closestDistance
end

local Skill = 
              {"Fireball", "Tsunami", "Freeze", "Heal", "HealBlast",
               "Shockwave", "LaserBeam", "LightningStrike",
               "Sandstorm", "Earthquake", "IceSpikes", "PolarVortex",
               "TeamHeal", "RainbowBlast", "PumpkinBlast", "Random",
               "Camouflage", "Tumble", "Flurry", "Boomerang",
               "ShockArrows", "ShocFlameArrowskwave", "BoomArows",
               "FrostArrows", "WeaponThrow", "WaveBlast",
               "InfernoWave", "SpikeField", "Berserk", "Pulsefire",
               "Cyclone", "BlackHole", "QuickSlash", "MeteorShower",
               "MeteorBlast", "Stomp"}

local Skill1 = 
               {"Fireball", "Tsunami", "Freeze", "Heal", "HealBlast",
                "Shockwave", "LaserBeam", "LightningStrike",
                "Sandstorm", "Earthquake", "IceSpikes", "PolarVortex",
                "TeamHeal", "RainbowBlast", "PumpkinBlast", "Random",
                "Camouflage", "Tumble", "Flurry", "Boomerang",
                "ShockArrows", "ShocFlameArrowskwave", "BoomArows",
                "FrostArrows", "WeaponThrow", "WaveBlast",
                "InfernoWave", "SpikeField", "Berserk", "Pulsefire",
                "Cyclone", "BlackHole", "QuickSlash", "MeteorShower",
                "MeteorBlast", "Stomp", "Bullet"}
  
function killAuraFast(monster)
if workspace:FindFirstChild("Dungeon") then
   for _, monster in pairs(workspace.Dungeon:GetDescendants()) do
    if monster:FindFirstChild("HumanoidRootPart") then
        if monster.Name ~= game.Players.LocalPlayer.Name then
            local monsterRootPart = monster.HumanoidRootPart
        
        for _, damage in ipairs(game:GetService("Workspace").Ignore:GetDescendants()) do
           if damage.Name == Skill or damage.Name == Skill1 or damage:FindFirstChildWhichIsA("TouchTransmitter") then
           local distance = (damage.Position - monster.HumanoidRootPart.Position).Magnitude
           
           if distance <= 500 then
               -- monster:FindFirstChild("HumanoidRootPart").CFrame = CFrame.new(damage.position + Vector3.new(0, 0, 1.5))
            -- monster:FindFirstChild("HumanoidRootPart").Position = damage.position + Vector3.new(0, 0, 1.5)
               firetouchinterest(monster.HumanoidRootPart, damage, 0)
               firetouchinterest(monster.HumanoidRootPart, damage, 1)
               firetouchinterest(damage, monster.HumanoidRootPart, 0)
               firetouchinterest(damage, monster.HumanoidRootPart, 1)
           -- damage.Size = Vector3.new(25, 10, 25)
          
          if not damage:FindFirstChildWhichIsA("TouchTransmitter") then
          warn("your ability is Teleport Mode")
          damage.CFrame = CFrame.new(monster.HumanoidRootPart.Position)
          end
            
            end
       end
     end
end
            
              end
          end
     end
end

function killAuraFast2(monster)
if workspace:FindFirstChild("Dungeon") then
   for _, monster in pairs(workspace.Dungeon:GetDescendants()) do
    if monster:IsA("Model") and monster:FindFirstChild("HumanoidRootPart") then
        if monster.Name ~= game.Players.LocalPlayer.Name then
            local monsterRootPart = monster.HumanoidRootPart
        
        for _, damage in ipairs(game:GetService("Workspace").Ignore:GetDescendants()) do
           if damage.Name == Skill or damage.Name == Skill1 or damage:FindFirstChildWhichIsA("TouchTransmitter") then
           local distance = (monster.HumanoidRootPart.Position - damage.Position).Magnitude
           
           if distance <= 500 then
             -- monster:FindFirstChild("HumanoidRootPart").CFrame = CFrame.new(damage.position + Vector3.new(0, 0, 1.5))
            -- monster:FindFirstChild("HumanoidRootPart").Position = damage.position + Vector3.new(0, 0, 1.5)
               firetouchinterest(monster.HumanoidRootPart, damage, 0)
               firetouchinterest(monster.HumanoidRootPart, damage, 1)
               firetouchinterest(damage, monster.HumanoidRootPart, 0)
               firetouchinterest(damage, monster.HumanoidRootPart, 1)
           -- damage.Size = Vector3.new(25, 10, 25)
          
          if not damage:FindFirstChildWhichIsA("TouchTransmitter") then
          warn("your ability is Teleport Mode")
          damage.CFrame = CFrame.new(monster.HumanoidRootPart.Position)
          end
            
              end
         end
    end
end
            
              end
          end
     end
end

local UwUSizeX = 10
local UwUSizeY = 10
local UwUSizeZ = 10
local UwUTrans = 1
local time = 0.5
local powerspeed = 0.5

function AbilityAura(monster)
if workspace:FindFirstChild("Dungeon") then
   for _, monster in pairs(workspace.Dungeon:GetDescendants()) do
    if monster:FindFirstChild("HumanoidRootPart") then
        if monster.Name ~= game.Players.LocalPlayer.Name then
            local monsterRootPart = monster.HumanoidRootPart
        
        for _, damage in ipairs(game:GetService("Workspace").Ignore:GetDescendants()) do
           if damage.Name == Skill or damage.Name == Skill1 or damage:FindFirstChildWhichIsA("TouchTransmitter") then
           local distance = (monster.HumanoidRootPart.Position - damage.Position).Magnitude
           
           if distance <= 500 then
             -- monster:FindFirstChild("HumanoidRootPart").CFrame = CFrame.new(damage.position + Vector3.new(0, 0, 1.5))
            -- monster:FindFirstChild("HumanoidRootPart").Position = damage.position + Vector3.new(0, 0, 1.5)
               firetouchinterest(monster.HumanoidRootPart, damage, 0)
               firetouchinterest(monster.HumanoidRootPart, damage, 1)
               firetouchinterest(damage, monster.HumanoidRootPart, 0)
               firetouchinterest(damage, monster.HumanoidRootPart, 1)
            damage.Size = Vector3.new(UwUSizeX, UwUSizeY, UwUSizeZ)
            damage.Transparency = UwUTrans
            wait(0.3)
            
            if monster:FindFirstChild("HumanoidRootPart") then
            damage.CFrame = CFrame.new(monster.HumanoidRootPart.Position)
            end
          
          if not damage:FindFirstChildWhichIsA("TouchTransmitter") then
          damage.CFrame = CFrame.new(monster.HumanoidRootPart.Position)
          end
            
            end
       end
  end
end  
            wait(0.1)
            
              end
          end
     end
end

local function AllKill()
killAuraFast(monster)
getNearestAttack()
killAuraFast(monster)
 killAuraFast(monster)
end

local function AllKill2()
    killAuraFast2(monster)
    getNearestAttack()
    killAuraFast2(monster)
    killAuraFast2(monster)
    RunService.RenderStepped:Wait()
end

local function AllKill3()
AbilityAura(monster)
end

local h = require(ReplicatedStorage.Shared.Modules.DungeonLibrary)

local Settings = {}

local Dungeons = {}
for i, v in pairs(h.Dungeons) do
    table.insert(Dungeons, i)
end
GameModes = {}
for i, v in pairs(h.GameModes) do
    table.insert(GameModes, i)
end
Difficulties = {}
for i, v in pairs(h.Difficulties) do
    table.insert(Difficulties, i)
end

x = 0

y = 0

z = -2

_G.TweenShrine = false
local shrineName = "Summoning"

function getShrines()
    local target
    local dungeon, rooms, enemies, shrines = getDungeon()
    local shrines = dungeon:WaitForChild("Shrines")
    for _, shrine in ipairs(shrines:GetChildren()) do
        if shrine:FindFirstChild("Primary") and shrine.Primary:FindFirstChild("ProximityPrompt") then
            if shrine.Name == shrineName then
                target = shrine
            end
        end
    end
    return target
end

function pressE()
    game:service('VirtualInputManager'):SendKeyEvent(true, "E", false, game)
end

function collectShrines(shrine)
if shrine.Primary then
    spawn(pressE)
    Tween({
        target = shrine,
        targetPart = shrine.Primary,
        newCFrame = CFrame.new(0, 0, 2.6)
    })
    end
end

function floating()
    while wait() do
        local player, cha, plr, hum = getPlayer()
        if not plr:FindFirstChild('BodyVelocity') then
            local BodyVelocity = Instance.new("BodyVelocity", plr)
            BodyVelocity.Velocity = Vector3.new()
            BodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            -- BodyVelocity.P = 1250
        end
    end
end

local SlowTween = false
local NormalTween = false
local FastTween = false
local MaliciousTween = false

function Tween(table, callback)
    local player, cha, plr, hum = getPlayer()
    local target, targetPart, newCFrame = table.target, table.targetPart, table.newCFrame

    local tic_k = tick();

    local distance = (targetPart.Position - plr.Position).Magnitude

    local movementSpeed = 0

    if SlowTween then
        if distance < 1 then
            movementSpeed = 70
        elseif distance < 10 then
            movementSpeed = 50
        elseif distance < 150 then
            movementSpeed = 20
        elseif distance < 200 then
            movementSpeed = 25
        elseif distance < 300 then
            movementSpeed = 30
        elseif distance < 500 then
            movementSpeed = 35
        elseif distance < 1000 then
            movementSpeed = 40
        else
            movementSpeed = 40
        end
    end

    if NormalTween then
        if distance < 1 then
            movementSpeed = 70
        elseif distance < 10 then
            movementSpeed = 55
        elseif distance < 1
